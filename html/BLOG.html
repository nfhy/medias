<h2>写在前面的话</h2>
<p>无意中在cocoaChina的首页看到了一篇介绍A*算法用swift实现的文章，对A*寻路算法产生了兴趣。在百度谷歌了很多文章后，终于A*算法的流程，同时让我发现了两篇非常好的英文文章：</p>
<p align="left"><a href="http://www.gamedev.net/page/resources/_/technical/artificial-intelligence/a-pathfinding-for-beginners-r2003">A* Pathfinding for Beginners</a></p>
<p align="left"><a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">Introduction to A*</a></p>
<p align="left">第一篇文章是非常好的A*算法入门文章，通读一遍就基本可以用代码实现了；第二篇文章可以说给我带来了震撼，原来算法可以这样讲，推荐大家都看一下。</p>
<p align="left">看完第二篇文章就产生了要学习作者的方式讲一下A*算法的冲动，同时也当是练练手，好久没写javaScript了。</p>
<p align="left">讲解方式也按照&lt;Introduction to A*&gt;一文中的顺序，从最简单的广度优先算法(Breadth-First-Search)、大名鼎鼎的Dijkstra算法到Greed-Best-First-Search算法，最后是A*算法。</p>
<p>（关于A*算法，网上资料很多，A*算法的变种也很多，有兴趣的朋友可以自行搜索，本文仅对四种常见寻路算法进行简单介绍，若有不合理或错误之处，请谅解并在回复中指出）</p>
<h2>广度优先算法</h2>
<p>广度优先算法是最简单的寻路算法，算法执行的结果是获得从地图上任意一点S到其他所有可达点的最短路径，这里只考虑上下左右四方向行走的情况，算法流程非常容易理解：</p>
<ol>
    <li>设定搜索起点S，放入openList中；</li>
    <li>判断openList是否为空，若为空，搜索结束；若不为空，拿出openList中的第一个节点G；</li>
    <li>遍历G的上下左右四个相邻节点N1-N4，对每个节点N，如果N不在openList或closeList中，那么令N的父节点为G，将N放入openList中；如果N已经在openList或closeList中，跳过不处理；</li>
    <li>将G放入closeList中，重复步骤2；</li>
</ol>
<p>演示程序：</p>
<p>&nbsp;</p>
<p>演示程序中，蓝色方块是不可通过的，S为扫描的起始点，一层层向外扩展，最终所有可到达的节点都被扫描，这一过程有时被称为&ldquo;flood fill&rdquo;。对于每一个被扫描的节点，为其添加一个指向父节点的方向箭头，然后你会发现，从地图上任意一点开始，只要沿着箭头的方向移动，总能走到起始点S，而且走过的路径必然是最短路径之一。</p>
<p>看到广度优先算法，最先想到的应用场景就是塔防，敌人总是从固定的一个或几个出生点出现，向着固定的一个或几个目标移动，我们完全可以在每一关开始前以出生点为起始点遍历整个地图，这样本关中怪物的移动路线就可以确定了。</p>
<p>下面让我们考虑以下场景，地图中存在森林、山岭和平原，角色在这些地形上移动时，移动力消耗是不同的，比如《文明》中。这就要求我们把每一个区块的消耗考虑在内，这时，Dijkstra算法就可以发挥作用了。</p>
<h2>Dijkstra算法</h2>
<p>在地图内的每个区块移动消耗不同时，Dijkstra算法可以非常方便的找出从地图上某个起始区块到其他所有可达区块的最短路径，这里仍然只考虑上下左右四个方向移动的情况，算法流程如下：</p>
<p>说明：起始区块记作S，从S到当前区块G的总移动消耗记作C<sub>G</sub>，优先队列openList中数据为(G,C<sub>G</sub>)（区块，S到当前区块总移动消耗）,区块G自身移动消耗记作Z<sub>G</sub>。</p>
<ol>
    <li>设定起始区块S，将区块S和总移动消耗C=0（记作(S,0)）放入openList，其中openList是一个优先队列(PriorityQueue)，总移动消耗C越低优先级越高；</li>
    <li>判断openList是否为空，如果是空，算法结束；否则，从openList中拿出优先级最高的区块G；</li>
    <li>遍历G的上下左右四个相邻区块N1-N4，对每个区块N，如果N已经在closeList中，忽略该区块；如果N不可达，忽略该区块；否则会有两种情况，</li>
</ol>
<p>a）如果N不在openList中，那么将(N,C<sub>N</sub>)放入openList中，其中C<sub>N</sub>=C<sub>G</sub>+Z<sub>N</sub>,既S到N的移动总消耗等于S到G的移动总消耗加上N本身的移动消耗，令N的父节点为G；</p>
<p>b）如果N已经在openList中，取出(N,C<sub>N</sub>)，仍然计算C<sub>N1</sub>=C<sub>G</sub>+Z<sub>N</sub>，如果C<sub>N1</sub>小于C<sub>N</sub>，用(N,C<sub>N1</sub>)替换openList中的(N,C<sub>N</sub>)，令N的父节点为G；如果C<sub>N1</sub>大于或等于C<sub>N</sub>，不做处理。</p>
<ol>
    <li>重复步骤2直至算法结束。</li>
</ol>
<p>演示程序：</p>
<p>&nbsp;</p>
<p>在演示程序中，蓝色区域不可通过，白色区块代表平原地形，移动一格消耗为1，绿色区块代表森林，移动一格消耗为5，黑色区块带表山脉，移动一格消耗为10。区块中的数字表示从起始点到当前区块的最小移动消耗。从演示程序可以看出，由于优先队列的存在，区块消耗越高，被扫描到的时间越靠后，这与广度优先算法中一层层向外扩展的方式不同。</p>
<p>不难想到，当地图上的所有区块移动消耗相同时，Dijkstra算法就退化为广度优先算法，因为移动总消耗最低的区块总会是当前区块的相邻区块。</p>
<p>在《Introduction to A*》中，作者提出了一个非常有趣的Dijkstra算法的应用，在这里和大家分享下：当我希望我的角色更倾向于经过某些区块时（比如经过这些区块可以获得增益效果、道具等等）或者倾向于躲避某些区块时（比如经过这些区块会丢失生命值，或者这些区块上的敌人非常危险），我们可以通过调整这些区块的移动消耗来影响移动路径的产生从而影响角色的移动行为。</p>
<p>广度优先算法和Dijkstra算法都需要遍历整个地图，而在大多数场景中，我们只需要知道一个点到另一个点的最短路径，下面的Greed-Best-First-Search为我们提供了一个思路。</p>
<h2>Greed-Best-First-Search</h2>
<p>网上没有找到比较官方的翻译，有人译作&ldquo;最好优先贪婪算法&rdquo;，我们暂时这么称呼它。最好优先贪婪算法与上面两种算法的不同之处在于，它总是尝试向离目标节点更近的方向探索，怎样才算离目标节点更近呢？在只能上下左右四方向移动的前提下，我们通过计算当前节点到目标节点的曼哈顿距离来进行判断。</p>
<p>假设当前节点坐标为(x,y)，目标节点的坐标为(x1,y1)，曼哈顿距离计算公式如下：</p>
<p>Manhattan_distance = abs(x1-x)+abs(y1-y)</p>
<p>由于曼哈顿距离只在两点之间没有障碍物的情况下才与实际距离相等，一般情况下曼哈顿距离总是小于实际距离。因此，当节点间不存在障碍物时，算法可以保证找出最短路径，但是一旦障碍物出现，最短路径就无法保证了。</p>
<p>算法流程如下：</p>
<p>说明：起始节点记作S，目标节点记作E，对于任意节点G，从当前节点G到目标节点E的曼哈顿距离记作M<sub>G</sub>，优先队列openList中数据为(G,M<sub>G</sub>)（节点，当前节点到目标节点E的曼哈顿距离）。</p>
<ol>
    <li>将起始节点S放入openList，openList是一个优先队列，曼哈顿距离越小的节点，优先级越高。</li>
    <li>判断openList是否为空，如果为空，搜索失败，目标节点E不可达；如果不为空，从openList中拿出优先级最高的节点G;</li>
    <li>遍历节点G的上下左右四个相邻节点N1-N4，如果N在openList或closeList中，忽略节点N；否则，令N的父节点为G，计算N到E的曼哈顿距离M<sub>N</sub>，将(N,M<sub>N</sub>)放入openList。</li>
    <li>判断节点G是不是目标节点E，如果是，搜索成功，获取节点G的父节点，并递归这一过程（继续获得父节点的父节点），直至找到初始节点S，从而获得从G到S的一条路径；否则，重复步骤2。</li>
</ol>
<p>演示程序：</p>
<p>&nbsp;</p>
<p>演示程序中，暗蓝色表示节点是障碍物，土黄色表示节点处于closeList中，淡蓝色表示节点处于openList中，白色表示节点处于搜索出的结果路径上。点击地图上的区块可以重新设置目标节点E。可以看出，当目标节点处于地图左下方时，搜索路径很明显不是最短路径。</p>
<p>最好优先贪婪算法虽然不能保证找出最短路径，但为我们提供了一个思路，A*算法就是Dijkstra算法与最好优先贪婪算法结合后得到的算法。</p>
<h2>A*算法</h2>
<p>A*算法与最好优先贪婪算法一样都通过计算一个值来判断探索的方向。对于节点N，计算公式如下：</p>
<p>F(N)=G(N)+H(N)</p>
<p>其中G(N)就是Dijkstra算法中计算的，从起点到当前节点N的移动消耗，而H(N)，在只允许上下左右移动的前提下，就是最好优先贪婪算法中当前节点N到目标节点E的曼哈顿距离。因此，当节点间移动消耗非常小时，G对F的影响也会微乎其微，A*算法就退化为最好优先贪婪算法；当节点间移动消耗非常大以至于H对F的影响微乎其微时，A*算法就退化为Dijkstra算法。</p>
<p>算法流程如下：</p>
<p>说明：起始节点记作S，目标节点记作E，对于任意节点P，从S到当前节点P的总移动消耗记作G<sub>P</sub>，节点P到目标E的曼哈顿距离记作H<sub>P</sub>，从节点P到相邻节点N的移动消耗记作D<sub>PN</sub>，用于优先级排序的值F(N)记作F<sub>P</sub>。</p>
<ol>
    <li>选择起始节点S和目标节点E，将(S,0)（节点，节点F(N)值）放入openList，openList是一个优先队列，节点F(N)值越小，优先级越高。</li>
    <li>判断openList是否为空，若为空，则搜索失败，目标节点不可达；否则，取出openList中优先级最高的节点P;</li>
    <li>遍历P的上下左右四个相邻接点N1-N4，对每个节点N，如果N已经在closeList中，忽略；否则有两种情况，</li>
</ol>
<p>a）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果N不在openList中，令G<sub>N</sub>=G<sub>P</sub>+D<sub>PN</sub>，计算N到E的曼哈顿距离H<sub>N</sub>，令F<sub>N</sub>=G<sub>N</sub>+H<sub>N</sub>，令N的父节点为P，将(N,F<sub>N</sub>)放入openList；</p>
<p>b）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果N已经在openList中，计算G<sub>N1</sub>= G<sub>P</sub>+D<sub>PN</sub>，如果G<sub>N1</sub>小于G<sub>N</sub>，那么用新的G<sub>N1</sub>替换G<sub>N</sub>，重新计算F<sub>N</sub>，用新的(N,F<sub>N</sub>)替换openList中旧的(N,F<sub>N</sub>)，令N的父节点为P；如果G<sub>N1</sub>不小于G<sub>N</sub>，不作处理。</p>
<ol>
    <li>将节点P放入closeList中。判断节点P是不是目标节点E，如果是，搜索成功，获取节点P的父节点，并递归这一过程（继续获得父节点的父节点），直至找到初始节点S，从而获得从P到S的一条路径；否则，重复步骤2。</li>
</ol>
<p>演示程序：</p>
<p>&nbsp;</p>
<p>演示程序中，土黄色表示节点在closeList中，淡蓝色表示节点在openList中，深蓝色表示节点不可通过，白色表示节点在搜索出的结果路径上。可以看出，A*算法总是设法保证搜索路径上的F值保持不变。</p>
<p>关于最优选择贪婪算法和A*算法中的曼哈顿距离的运用属于启发式算法(Heuristic Algrathm)的一种，这也是A*算法公式F=G+H中H的由来。</p>
<p>这里摘抄一段《Introduction to A*》的作者在另一篇文章《Heuristic》中的一小段，讲述H(n)如何影响A*算法的行为。</p>
<ul>
    <li>At one extreme, if&nbsp;h(n)&nbsp;is 0, then only&nbsp;g(n)&nbsp;plays a role, and A* turns into Dijkstra&rsquo;s algorithm, which is guaranteed to find a shortest path.</li>
    <li>If&nbsp;h(n)&nbsp;is always lower than (or equal to) the cost of moving from&nbsp;n&nbsp;to the goal, then A* is guaranteed to find a shortest path. The lower&nbsp;h(n)&nbsp;is, the more node A* expands, making it slower.</li>
    <li>If&nbsp;h(n)&nbsp;is exactly equal to the cost of moving from&nbsp;n&nbsp;to the goal, then A* will only follow the best path and never expand anything else, making it very fast. Although you can&rsquo;t make this happen in all cases, you can make it exact in some special cases. It&rsquo;s nice to know that given perfect information, A* will behave perfectly.</li>
    <li>If&nbsp;h(n)&nbsp;is sometimes greater than the cost of moving from&nbsp;n&nbsp;to the goal, then A* is not guaranteed to find a shortest path, but it can run faster.</li>
</ul>
<p>At the other extreme, if&nbsp;h(n)&nbsp;is very high relative to&nbsp;g(n), then only&nbsp;h(n)&nbsp;plays a role, and A* turns into Greedy Best-First-Search.</p>
<ol>
    <li>一种极端情况是，当H(n)=0时，只有G(0)有效，此时A*算法变为Dijkstra算法，可以保证找到最短路径。</li>
    <li>如果H(n)总能保证不大于从n到终点的实际距离，那么A*算法就可以保证找到最短路径（如上面演示程序中，在智能上下左右四方向移动的前提下，曼哈顿距离总是小于或等于实际距离）。H(n)相比实际距离越小，A*算法需要探索的节点就更多，性能就会更差一些。</li>
    <li>如果H(n)与n到终点的实际距离相等，那么A*算法就可以一直保持探索路径在最优路径上而不需要探索额外的节点，使得算法执行非常快。虽然这是理想状态下的场景，但是如果提前对地图进行分析，我们还是可以保证A*算法在近似理想的状态下工作。（关于A*算法的优化后面会讲到）</li>
    <li>另一种极端情况是，当H(n)相对于G(n)非常大时，只有H(n)有效，A*算法就会变成最优选择贪婪算法，不能保证找到最短路径。</li>
    <li>虽然最优选择贪婪算法只在特定情况下才可以找到最短路径（没有障碍物、没有地形移动消耗差异），但是它的运行速度是最快的。如果情况允许，优先使用本算法。</li>
    <li>当需要知道地图上某个点到所有其他点的最短路径，或者反过来，地图上所有点到某个点的最短路径时，选择广度优先算法（各区块移动消耗相同）或Dijkstra算法（各区块移动消耗不同）。</li>
    <li>在一般情况下，使用A*算法总是正确的。</li>
</ol>
<h2>以上四种算法的选择</h2>
<h2>A*算法的一般优化</h2>
<p>在情况允许的前提下，在生成地图或者加载地图时，记录地图上的特征区域。特征区域分为两类：</p>
<p>第一类是不可到达区域，当目标点位于不可到达区域时，以上四类算法都会进行全图扫描，这绝对是资源的极大浪费；</p>
<p>第二类是导航点，所谓导航点，就是地图上两个区域间移动的必经之路，例如游戏中两片陆地被河流分割，中间一座小桥，从一块陆地前往另一块陆地必然经过这座桥，可以先算出起点到这座桥的最短路径，再算出这座桥到终点的最短路径，那么两者加起来就是起点到终点的最短路径，同理，地图分为两层，楼梯的部分也是导航点。</p>